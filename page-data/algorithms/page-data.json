{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithms/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"6c12791e-74dd-5a9d-93f7-5d82dd08d577","excerpt":"제…","html":"<h1>제1장 알고리즘 소개</h1>\n<p>이 장에서는 우선 알고리즘의 정의와 특성을 살펴보고, 앞으로 교재에서 다룰 다양한 알고리즘을 설계하고 분석하는 데 꼭 필요한 기본적인 내용으로 알고리즘의 대표적인 설계기법과 알고리즘의 성능을 분석하고 표기하는 방법을 중심으로 학습한다.</p>\n<h2>학습목표</h2>\n<ol>\n<li>알고리즘의 중요성과 정의 및 특성을 이해할 수 있다.</li>\n<li>알고리즘을 설계하는 주요 기법의 종류와 개념을 이해하고 설명할 수 있다.</li>\n<li>알고리즘을 분석하는 방법과 점근성능의 표기법을 이해하고 적용할 수 있다.</li>\n<li>순환 알고리즘의 점화 관계를 이해할 수 있다.</li>\n</ol>\n<h2>주요용어</h2>\n<p>알고리즘 / 욕심쟁이 방법 / 거스름돈 문제 / 배낭 문제 / 분할정복 방법 / 동적 프로그래밍 방법 / 시간 복잡도 / 공간 복잡도 / 점근성능 / O-표기 / Ω-표기 / Θ-표기 / 점근적 상한 / 점근적 하한 / 순환 알고리즘 / 점화식 / 폐쇄형</p>\n<h1>1.1 기본개념</h1>\n<h2>예제 1.1</h2>\n<blockquote>\n<p>주어진 배열에서 가장 작은 값을 찾는 문제의 알고리즘을 작성하시오.</p>\n</blockquote>\n<p>A[] = {80, 70, 40, 20, 30, 10, 60, 50}</p>\n<h2>풀이</h2>\n<p>주어진 데이터에 대해서 최솟값(또는 최댓값)을 찾는 기본적인 방법은 각 숫자를 차례대로 하나씩 모두 비교하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">단계 1. 입력 배열 중에서 첫번째 데이터를 최솟값으로 지정한다.  \n단계 2. 배열에서 다음 숫자를 읽고, 이것과 저장된 최솟값을 비교한다.  \n단계 3. 비교 후 더 작은 숫자를 최솟값으로 다시 지정한다.  \n단계 4. 배열에 처리할 데이터가 남아 있으면 [단계 2]로 간다.\n단계 5. 저장된 최솟값을 결과로 출력한다.</code></pre></div>\n<h2>예제 1.2</h2>\n<blockquote>\n<p>주어진 그래프에 대해 임의의 한 점에서 출발해서 모든 선분을 한번씩만 지나는 경로의 존재 여부를 확인하시오. 단 각 점은 여러번 방문해도 무관하다.</p>\n</blockquote>\n<h2>풀이</h2>\n<p>그래프의 모든 간선을 오직 한번씩만 지나가는 경로를 찾는 문제를 오일러 경로(Eulerian path) 문제라고 한다.<br>\n오일러 경로의 존재 여부를 확인하는 규칙은 다음과 같다. 각 정점의 차수(해당 정점에 부수된 간선의 개수)가 홀수인 정점이 없거나 2개이면 오일러 경로가 존재하며, 만약 차수가 홀수인 정점이 2개일 경우에는 반드시 홀수 정점에서 시작해야만 한다.<br>\n특히 홀수 정점이 0개인 경우에는 출발점과 도착점이 같은 오일러 경로가 되며, 이를 오일러 회로라고 한다.<br>\n이러한 규칙을 적용하면 그래프 (a)는 오일러 회로가 되지만, 그래프 (b)는 홀수 정점이 4개이므로 오일러 경로가 존재하지 않는다.</p>\n<h2>예제 1.3</h2>\n<blockquote>\n<p>주어진 그래프는 각 도시간의 이동 거리를 나타낸다. 이때 서울에서 출발하여 부산까지 이동하는 가장 짧은 거리를 갖는 경로를 찾으시오.</p>\n</blockquote>\n<h2>풀이</h2>\n<p>하나의 출발점을 기준으로 다른 모든 정점(도시)으로의 최단 경로를 구하는 문제는 다익스트라(Dijkstra) 알고리즘으로 해결할 수 있다.<br>\n따라서 서울을 기준으로 부산까지의 최단 경로는 '서울-천안-논산-대전-진주-부산'이며, 최소거리는 39이다. 참고로, 모든 정점 쌍 간의 최단 경로, 즉 이 경우에는 임의의 두 도시간의 최단 경로를 찾는 문제는 플로이드(Floyd) 알고리즘을 적용한다.</p>\n<h1>1.2 알고리즘 설계</h1>\n<h2>[알고리즘 1.1] 순차탐색</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SequentialSearch (A[], n, key)\n입력: A[0..n-1] : 입력 배열\n     n : 배열 크기(데이터 개수)\n     key : 탐색 키(찾으려는 값)\n출력: key가 배열 내에 존재하면 해당 인덱스, 아니면 n을 반환\n{\n  i = 0;\n  while (i &lt; n &amp;&amp; A[i] != key)\n    i = i + 1;\n  return (i);\n}</code></pre></div>\n<h2>[알고리즘 1.2] 이진탐색</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">BinarySearch (A[], key, Left, Right)\n입력: A[Left..Right] : 입력 배열\n     key : 탐색 키\n출력: key가 A[]내에 존재하면 해당 인덱스, 아니면 -1을 반환\n{\n  if (Left > Right) return (-1);\n  Mid = (Left + Right) / 2; // 소수점 버림(floor 연산)\n  if (A[Mid] == key) return (Mid);\n  else if (key &lt; A[Mid]) BinarySearch(A, key, Left, Mid-1)\n    else BinarySearch(A, key, Mid+1, Right);\n}</code></pre></div>\n<h2>1.2.1 Greedy 방법</h2>\n<p>욕심쟁이 방법은 일련의 선택 과정을 통해 해를 찾는데, 이때 전후 단계의 선택과는 상관없이 각 단계마다 정해진 기준에 따라 가장 최선이라고 여겨지는 <strong>국부적인(local) 최적해를 선택해 나가면 결과적으로 전체적인(global) 최적해를 구할 수 있을 것이라는 희망적인 전략</strong>을 취하는 방법이다.<br>\n여기서 희망적이라는 표현은, 각 단계에서 전후 단계의 선택의 대해서는 아무런 고려없이 단지 현재 상태에서만 만족하는 최적해만을 선택하기 때문에 국부적인 최적해가 항상 전체적인 최적해를 만들지 못할 수도 있음을 의미한다.<br>\n이처럼 욕심쟁이 방법으로 해를 구할 수 없는 문제도 있으므로 적용 범위가 제한적이라는 한계를 갖지만, 어떤 문제에 욕심쟁이 방법이 적용가능하다면 최적해를 보장하는 효율적인 알고리즘을 아주 간단하게 만들 수 있는 강력한 설계기법임은 틀림없다.<br>\n이 방법은 가능한 여러 해 중에서 최솟값이나 최댓값을 찾는 최적해 문제의 해결에 주로 사용된다.</p>\n<p>욕심쟁이 방법이 적용된 대표적인 알고리즘은 거스름돈 문제나 배낭 문제와 같이 비교적 간단한 것을 비롯하여 최소 신장 트리를 구하는 크루스칼 알고리즘과 프림 알고리즘, 그리고 단일 출발점에 대한 최단 경로를 구하는 데이크스트라 알고리즘 등이 있다.</p>\n<h2>예제 1.4</h2>\n<blockquote>\n<p>거스름돈이 780원일 때 고객에게 돌려줄 동전의 최소 개수를 구하시오. 단, 사용할 수 있는 동전의 종류는 500원, 100원, 50원, 10원의 네 종류가 있다고 가정한다.</p>\n</blockquote>\n<h2>풀이</h2>\n<p>거스름돈 문제는 가게에서 고객에게 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제이다.<br>\n욕심쟁이 방법을 적용한 거스름돈 문제의 해법은 거스름돈의 액수를 초과하지 않으면서 단순히 액면가가 큰 동전부터 '욕심을 부려서' 최대한 뽑아서 거스름돈을 만드는 것이다.</p>\n<p>따라서 주어진 문제의 거스름돈 780원에 대해서는, 먼저 액면가가 가장 큰 500원짜리 동전을 최대한 뽑으면 하나가 되고, 남은 280원에 대하여 다음으로 액면가가 큰 100원짜리 동전을 최대한 2개 뽑는다.<br>\n마찬가지로 남은 80원에 대하여 50원짜리 1개와 10원짜리 3개를 차례대로 뽑는다. 그러면 최종적으로 얻은 동전의 개수는 500원짜리 1개, 100원짜리 2개, 50원짜리 1개, 10원짜리 3개로서 총 7개가 된다.</p>\n<h2>예제 1.5</h2>\n<blockquote>\n<p>거스름돈이 650원인 거스름돈 문제의 최적해를 욕심쟁이 방법으로 구하시오. 단, 동전의 종류는 500원, 120원, 100원, 50원, 10원의 다섯 종류가 있다고 가정한다.</p>\n</blockquote>\n<h2>풀이</h2>\n<p>앞선 [예제 1.4]의 동전 종류 (500원, 100원, 50원, 10원)에 액면가가 120원인 동전이 더 있다고 가정한 경우이다. 거스름돈 650원에 대해서 욕심쟁이 방법을 적용하면, 650원에 대해서 500원짜리 동전 1개, 남은 150원에 대해서는 120원짜리 동전 1개, 그리고 남은 30원에 대해서 10원짜리 동전 3개를 고르면 결국 최소 동전의 개수는 5개이다.<br>\n욕심쟁이 방법을 적용한 거스름돈 문제의 해법은 거스름돈의 액수를 초과하지 않으면서 단순히 액면가가 큰 동전부터 '욕심을 부려서' 최대한 뽑아서 거스름돈을 만드는 것이다.</p>\n<p>그런데 불행하게도 욕심쟁이 방법으로 구한 동전의 최소 개수, 즉 5개는 최적해가 아니다. 500원짜리 동전 1개, 100원짜리 동전 1개, 그리고 50원짜리 동전 1개를 고르면 최소 3개의 동전으로 650원을 만들 수 있다.<br>\n이와 같이 같은 거스름돈 문제라고 할지라도 동전의 액면가가 일반적인 경우에는 욕심쟁이 방법을 적용할 수는 없고 다른 방법을 통해서 최적해를 구해야 한다.</p>\n<h2>예제 1.6</h2>\n<blockquote>\n<p>다음과 같은 조건의 배낭 문제에 대해 욕심쟁이 방법을 적용해서 최대 이익을 구하시오.</p>\n</blockquote>\n<ul>\n<li>배낭의 용량 M → 10</li>\n<li>물체의 개수 n → 4</li>\n<li>물체 1의 이익(p1)과 무게(w1) → 18, 3</li>\n<li>물체 2의 이익(p2)과 무게(w2) → 15, 5</li>\n<li>물체 3의 이익(p3)과 무게(w3) → 12, 3</li>\n<li>물체 4의 이익(p4)과 무게(w4) → 25, 4</li>\n</ul>\n<h2>풀이</h2>\n<p>배낭문제에 대한 기본적인 아이디어는 배낭의 용량이 제한되어 있으므로 배낭의 용량을 가능한 한 조금 차지하면서도 이익이 많은 물체부터 배낭에 <strong>'욕심을 부려서'</strong> 최대한 넣는 과정을 반복하면 된다.<br>\n만약 물체를 통째로 넣을 수 없는 경우라면 남은 배남의 용량에 맞게 물체를 쪼개서 넣으면 된다. 여기서 중요한 것은 각 단계의 선택기준, 즉 각 단계에서 어떤 물체를 넣을 것인가를 정하는 것이다. 물체를 쪼갤 수 있다고 가정했으므로 단순히 물체의 이익을 취하기보다는 단위 무게당 이익을 계산하고, 이것이 최대가 되는 물체부터 최대한 배낭에 넣으면 최적해를 구할 수 있다.<br>\n주어진 문제에 대해서 우선 단위 무게당 이익을 구하면 다음과 같다.</p>\n<p>$$\n\\begin{pmatrix}\n\\frac{p_1}{w_1},\\frac{p_2}{w_2},\\frac{p_3}{w_3},\\frac{p_4}{w_4}\n\\end{pmatrix} =\n\\begin{pmatrix}\n\\frac{18}{3},\\frac{15}{5},\\frac{12}{3},\\frac{25}{4}\n\\end{pmatrix} =\n\\begin{pmatrix}\n6, 3, 4, 6.25\n\\end{pmatrix}\n$$</p>\n<p>단위 무게당 이익이 큰 순서인 물체4, 물체1, 물체3, 그리고 물체2의 순으로 배낭에 물체를 넣는다. 따라서 물체4를 배낭에 넣으면 배낭의 용량은 10에서 물체4의 무게(4)만큼 줄어들기 때문에 남은 배낭의 용량은 6이 된다. 이제 물체1을 배낭에 넣으면 남은 배낭의 용량은 6이 된다. 이제 물체1을 배낭에 넣으면 남은 배낭의 용량은 6에서 3으로 감소한다. 다시 물체3을 배낭에 넣으면 남은 배낭의 용량(3)과 물체3의 무게(3)가 같으므로 배낭이 꽉 차게 되고 더 이상 배낭에 물체를 넣을 수 없게 된다.<br>\n배낭에는 물체4, 물체1, 물체3이 들어 있으므로, 얻을 수 있는 최대 이익은 25 + 18 + 12 = 55 가 된다.</p>","frontmatter":{"title":"Algorithms","date":"March 12, 2025","description":"This is a custom description for SEO and Open Graph purposes, rather than the default generated excerpt. Simply add a description field to the frontmatter."}},"previous":{"fields":{"slug":"/new-beginnings/"},"frontmatter":{"title":"New Beginnings"}},"next":{"fields":{"slug":"/coding-patterns-java/"},"frontmatter":{"title":""}}},"pageContext":{"id":"6c12791e-74dd-5a9d-93f7-5d82dd08d577","previousPostId":"4736fd65-70a0-5204-ac2f-99d7082ff7b0","nextPostId":"91a2dad8-e5d9-562b-a211-306e5c8e1f11"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}